'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _errors = require('./errors');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var defaultHandler = function defaultHandler(err, stack) {
  var res = {};
  res.status = err.name;
  res.message = err.message;
  res.code = err.code;
  if (stack) res.stackTrace = err.stack;
  return res;
};

var Exception = function (_Error) {
  _inherits(Exception, _Error);

  function Exception(msg) {
    _classCallCheck(this, Exception);

    var _this = _possibleConstructorReturn(this, (Exception.__proto__ || Object.getPrototypeOf(Exception)).call(this, msg));

    _this.message = msg;
    _this.name = 'Express-Simple-Errors Exception';
    Error.captureStackTrace(_this);
    return _this;
  }

  return Exception;
}(Error);

// TODO
// Logging Middleware?


var ErrorHandler = function () {
  function ErrorHandler(opts) {
    _classCallCheck(this, ErrorHandler);

    this.handlers = new Map();
    this.handlers.set('Default', defaultHandler);
    this.stackTrace = true;
    if (opts && opts.stackTrace !== undefined) {
      if (typeof opts.stackTrace !== 'boolean') throw new Exception('Option stackTrace must be a boolean.');
      this.stackTrace = opts.stackTrace;
    }
  }

  _createClass(ErrorHandler, [{
    key: 'setHandler',
    value: function setHandler(name, handler) {
      if (!name || !handler) throw new Exception('Method setHandler requires both name and handler parameters.');
      if (typeof handler !== 'function') throw new Exception('Method setHandler expects the handler parameter to be a function.');
      return this.handlers.set(name, handler);
    }
  }, {
    key: 'unsetHandler',
    value: function unsetHandler(name) {
      if (!name) throw new Exception('Method unsetHandler requires name parameter');
      if (name === 'Default') return this.handlers.set('Default', defaultHandler);
      return this.handlers.delete(name);
    }
  }, {
    key: 'handleNotFound',
    value: function handleNotFound(req, res, next) {
      next(new _errors.NotFound());
    }
  }, {
    key: 'handleError',
    value: function handleError(err, req, res, next) {
      if (!err.code) {
        err.message = 'Internal Server Error';
        err.code = 500;
      }

      var handler = this.handlers.get(err.name) || this.handlers.get('Default');
      res.locals.errors = handler(err, this.stackTrace);
      next(err);
    }
  }, {
    key: 'sendResponse',
    value: function sendResponse(err, req, res, next) {
      // eslint-disable-line
      res.status(err.code).json(res.locals.errors);
    }
  }, {
    key: 'middleware',
    value: function middleware() {
      return [this.handleNotFound, this.handleError.bind(this), this.sendResponse];
    }
  }]);

  return ErrorHandler;
}();

exports.default = ErrorHandler;